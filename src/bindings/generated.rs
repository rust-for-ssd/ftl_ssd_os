/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8)
            .offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = (core::ptr::addr_of_mut!((*this).storage) as *mut u8)
            .offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>(),
        );
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!(
            (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>(),
        );
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const RING_NAME_SIZE: u32 = 32;
pub const CACHE_LINE_SIZE: u32 = 64;
pub const RING_FLAG_SINGLE_CONS: u32 = 2;
pub const RING_FLAG_SINGLE_PROD: u32 = 4;
pub const RING_FLAG_RUNNING: u32 = 1;
pub const LOCKLESS_RING: u32 = 1;
pub const AND64: i32 = -1;
pub const ZERO_32FLAG: u32 = 0;
pub const SEC64: u32 = 1000000;
pub const NVM_CH_IN_USE: u32 = 60;
pub const MAX_NAME_SIZE: u32 = 31;
pub const NVM_FTL_QUEUE_SIZE: u32 = 2048;
pub const NVM_QUEUE_RETRY: u32 = 10000;
pub const NVM_QUEUE_RETRY_SLEEP: u32 = 200;
pub const NVM_FTL_QUEUE_TO: u32 = 10000000;
pub const NVM_SYNCIO_TO: u32 = 10;
pub const NVM_SYNCIO_FLAG_BUF: u32 = 1;
pub const NVM_SYNCIO_FLAG_SYNC: u32 = 2;
pub const NVM_SYNCIO_FLAG_DEC: u32 = 4;
pub const NVM_SYNCIO_FLAG_MPL: u32 = 8;
pub const NVM_MAGIC: u32 = 60;
pub const NVM_TRANS_TO_NVM: u32 = 0;
pub const NVM_TRANS_FROM_NVM: u32 = 1;
pub const NVM_IO_NORMAL: u32 = 0;
pub const NVM_IO_RESERVED: u32 = 1;
pub const NVM_CMD_ADMIN: u32 = 0;
pub const NVM_CMD_IO: u32 = 1;
pub const MAGIC_EXTENSION: &::core::ffi::CStr = c"ext";
pub const MAGIC_STAGE: &::core::ffi::CStr = c"stg";
pub const MAGIC_CONNECTOR: &::core::ffi::CStr = c"con";
pub const TICKS_SEC: u32 = 10000000;
pub const TICKS_MSEC: u32 = 10000;
pub const TICKS_USEC: u32 = 10;
pub const VOLT_MEM_ERROR: u32 = 0;
pub const VOLT_MEM_OK: u32 = 1;
pub const VOLT_SECOND: u32 = 1000000;
pub const VOLT_CHIP_COUNT: u32 = 2;
pub const VOLT_VIRTUAL_LUNS: u32 = 2;
pub const VOLT_BLOCK_COUNT: u32 = 16;
pub const VOLT_PAGE_COUNT: u32 = 64;
pub const VOLT_SECTOR_COUNT: u32 = 4;
pub const VOLT_PLANE_COUNT: u32 = 2;
pub const VOLT_PAGE_SIZE: u32 = 16384;
pub const VOLT_SECTOR_SIZE: u32 = 4096;
pub const VOLT_SEC_OOB_SIZE: u32 = 16;
pub const VOLT_OOB_SIZE: u32 = 64;
pub const VOLT_DMA_SLOT_CH: u32 = 32;
pub const VOLT_DMA_SLOT_INDEX: u32 = 64;
pub const VOLT_DMA_READ: u32 = 1;
pub const VOLT_DMA_WRITE: u32 = 2;
pub const VOLT_BLK_LIFE: u32 = 5000;
pub const VOLT_RSV_BLK: u32 = 1;
pub const VOLT_READ_TIME: u32 = 50;
pub const VOLT_WRITE_TIME: u32 = 200;
pub const VOLT_ERASE_TIME: u32 = 1200;
pub const VOLT_QUEUE_SIZE: u32 = 2048;
pub const VOLT_QUEUE_TO: u32 = 48000;
#[repr(C)]
#[repr(align(64))]
#[derive(Debug, Copy, Clone)]
pub struct lring {
    pub name: [::core::ffi::c_char; 32usize],
    pub alloc_mem: ::core::ffi::c_int,
    pub ring_start: *mut ::core::ffi::c_void,
    pub last_entry: *mut ::core::ffi::c_void,
    pub ring_size: ::core::ffi::c_int,
    pub entry_size: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_int,
    pub id: ::core::ffi::c_int,
    pub sem: ::core::ffi::c_int,
    pub prod: lring_prod,
    pub __bindgen_padding_0: [u32; 13usize],
    pub cons: lring_cons,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lring_prod {
    pub sp_enqueue: ::core::ffi::c_int,
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lring_cons {
    pub sc_dequeue: ::core::ffi::c_int,
    pub head: *mut ::core::ffi::c_void,
    pub tail: *mut ::core::ffi::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lring_entry {
    pub function: *mut ::core::ffi::c_void,
    pub ctx: *mut ::core::ffi::c_void,
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub const NVM_DMA_TO_HOST: _bindgen_ty_1 = 0;
pub const NVM_DMA_FROM_HOST: _bindgen_ty_1 = 1;
pub const NVM_DMA_SYNC_READ: _bindgen_ty_1 = 2;
pub const NVM_DMA_SYNC_WRITE: _bindgen_ty_1 = 3;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
pub const MMGR_READ_PG: _bindgen_ty_2 = 1;
pub const MMGR_READ_OOB: _bindgen_ty_2 = 2;
pub const MMGR_WRITE_PG: _bindgen_ty_2 = 3;
pub const MMGR_BAD_BLK: _bindgen_ty_2 = 5;
pub const MMGR_ERASE_BLK: _bindgen_ty_2 = 7;
pub const MMGR_READ_SGL: _bindgen_ty_2 = 8;
pub const MMGR_WRITE_SGL: _bindgen_ty_2 = 9;
pub const MMGR_WRITE_PL_PG: _bindgen_ty_2 = 16;
pub const MMGR_READ_PL_PG: _bindgen_ty_2 = 17;
pub type _bindgen_ty_2 = ::core::ffi::c_uint;
pub const NVM_ERROR_EMAX_NAME_SIZE: NVM_ERROR = 1;
pub const NVM_ERROR_EMMGR_REGISTER: NVM_ERROR = 2;
pub const NVM_ERROR_EPCIE_REGISTER: NVM_ERROR = 3;
pub const NVM_ERROR_EFTL_REGISTER: NVM_ERROR = 4;
pub const NVM_ERROR_ENVME_REGISTER: NVM_ERROR = 5;
pub const NVM_ERROR_ECH_CONFIG: NVM_ERROR = 6;
pub const NVM_ERROR_EMEM: NVM_ERROR = 7;
pub const NVM_ERROR_ENOMMGR: NVM_ERROR = 8;
pub const NVM_ERROR_ENOFTL: NVM_ERROR = 9;
pub const NVM_ERROR_EPARSER_REGISTER: NVM_ERROR = 10;
pub const NVM_ERROR_ENOPARSER: NVM_ERROR = 11;
pub const NVM_ERROR_ENOTRANSP: NVM_ERROR = 12;
pub const NVM_ERROR_ETRANSP_REGISTER: NVM_ERROR = 13;
pub type NVM_ERROR = ::core::ffi::c_uint;
pub const NVM_IO_SUCCESS: _bindgen_ty_3 = 1;
pub const NVM_IO_FAIL: _bindgen_ty_3 = 2;
pub const NVM_IO_PROCESS: _bindgen_ty_3 = 3;
pub const NVM_IO_NEW: _bindgen_ty_3 = 4;
pub const NVM_IO_TIMEOUT: _bindgen_ty_3 = 5;
pub type _bindgen_ty_3 = ::core::ffi::c_uint;
pub const RUN_FLAGS_RUN_READY: RUN_FLAGS = 1;
pub const RUN_FLAGS_RUN_NVME_ALLOC: RUN_FLAGS = 2;
pub const RUN_FLAGS_RUN_MMGR: RUN_FLAGS = 4;
pub const RUN_FLAGS_RUN_FTL: RUN_FLAGS = 8;
pub const RUN_FLAGS_RUN_CH: RUN_FLAGS = 16;
pub const RUN_FLAGS_RUN_TRANSPORT: RUN_FLAGS = 32;
pub const RUN_FLAGS_RUN_NVME: RUN_FLAGS = 64;
pub const RUN_FLAGS_RUN_OXAPP: RUN_FLAGS = 128;
pub const RUN_FLAGS_RUN_FABRICS: RUN_FLAGS = 256;
pub const RUN_FLAGS_RUN_PARSER: RUN_FLAGS = 512;
pub type RUN_FLAGS = ::core::ffi::c_uint;
pub const OX_MEM_TYPES_OX_MEM_CMD_ARG: OX_MEM_TYPES = 0;
pub const OX_MEM_TYPES_OX_MEM_ADMIN: OX_MEM_TYPES = 1;
pub const OX_MEM_TYPES_OX_MEM_CORE_INIT: OX_MEM_TYPES = 2;
pub const OX_MEM_TYPES_OX_MEM_CORE_EXEC: OX_MEM_TYPES = 3;
pub const OX_MEM_TYPES_OX_MEM_OX_MQ: OX_MEM_TYPES = 4;
pub const OX_MEM_TYPES_OX_MEM_FTL_LNVM: OX_MEM_TYPES = 5;
pub const OX_MEM_TYPES_OX_MEM_MMGR: OX_MEM_TYPES = 6;
pub const OX_MEM_TYPES_OX_MEM_TCP_SERVER: OX_MEM_TYPES = 7;
pub const OX_MEM_TYPES_OX_MEM_MMGR_VOLT: OX_MEM_TYPES = 8;
pub const OX_MEM_TYPES_OX_MEM_MMGR_OCSSD: OX_MEM_TYPES = 9;
pub const OX_MEM_TYPES_OX_MEM_FTL: OX_MEM_TYPES = 10;
pub const OX_MEM_TYPES_OX_MEM_OXAPP: OX_MEM_TYPES = 11;
pub const OX_MEM_TYPES_OX_MEM_APP_TRANS: OX_MEM_TYPES = 12;
pub const OX_MEM_TYPES_OX_MEM_APP_CH: OX_MEM_TYPES = 13;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_LOG: OX_MEM_TYPES = 14;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_LBA: OX_MEM_TYPES = 15;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_GPR: OX_MEM_TYPES = 16;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_GMAP: OX_MEM_TYPES = 17;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_GC: OX_MEM_TYPES = 18;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_CPR: OX_MEM_TYPES = 19;
pub const OX_MEM_TYPES_OX_MEM_OXBLK_REC: OX_MEM_TYPES = 20;
pub const OX_MEM_TYPES_OX_MEM_FABRICS: OX_MEM_TYPES = 21;
pub const OX_MEM_TYPES_OX_MEM_NVMEF: OX_MEM_TYPES = 22;
pub const OX_MEM_TYPES_OX_MEM_MMGR_FILEBE: OX_MEM_TYPES = 23;
pub const OX_MEM_TYPES_OX_MEM_ELEOS_W: OX_MEM_TYPES = 29;
pub const OX_MEM_TYPES_OX_MEM_ELEOS_LBA: OX_MEM_TYPES = 30;
pub const OX_MEM_TYPES_OX_MEM_APP_HMAP: OX_MEM_TYPES = 31;
pub type OX_MEM_TYPES = ::core::ffi::c_uint;
pub const ox_stats_recovery_types_OX_STATS_REC_CP_READ_US: ox_stats_recovery_types = 0;
pub const ox_stats_recovery_types_OX_STATS_REC_BBT_US: ox_stats_recovery_types = 1;
pub const ox_stats_recovery_types_OX_STATS_REC_BLK_US: ox_stats_recovery_types = 2;
pub const ox_stats_recovery_types_OX_STATS_REC_CH_MAP_US: ox_stats_recovery_types = 3;
pub const ox_stats_recovery_types_OX_STATS_REC_GL_MAP_US: ox_stats_recovery_types = 4;
pub const ox_stats_recovery_types_OX_STATS_REC_REPLAY_US: ox_stats_recovery_types = 5;
pub const ox_stats_recovery_types_OX_STATS_REC_CP_WRITE_US: ox_stats_recovery_types = 6;
pub const ox_stats_recovery_types_OX_STATS_REC_START1_US: ox_stats_recovery_types = 7;
pub const ox_stats_recovery_types_OX_STATS_REC_START2_US: ox_stats_recovery_types = 8;
pub const ox_stats_recovery_types_OX_STATS_REC_LOG_PGS: ox_stats_recovery_types = 9;
pub const ox_stats_recovery_types_OX_STATS_REC_LOG_SZ: ox_stats_recovery_types = 10;
pub const ox_stats_recovery_types_OX_STATS_REC_DROPPED_LOGS: ox_stats_recovery_types = 11;
pub const ox_stats_recovery_types_OX_STATS_REC_TR_COMMIT: ox_stats_recovery_types = 12;
pub const ox_stats_recovery_types_OX_STATS_REC_TR_ABORT: ox_stats_recovery_types = 13;
pub type ox_stats_recovery_types = ::core::ffi::c_uint;
pub const ox_stats_cp_types_OX_STATS_CP_LOAD_ADDR: ox_stats_cp_types = 0;
pub const ox_stats_cp_types_OX_STATS_CP_MAP_EVICT: ox_stats_cp_types = 1;
pub const ox_stats_cp_types_OX_STATS_CP_MAPMD_EVICT: ox_stats_cp_types = 2;
pub const ox_stats_cp_types_OX_STATS_CP_BLK_EVICT: ox_stats_cp_types = 3;
pub const ox_stats_cp_types_OX_STATS_CP_MAP_BIG_SZ: ox_stats_cp_types = 4;
pub const ox_stats_cp_types_OX_STATS_CP_MAP_SMALL_SZ: ox_stats_cp_types = 5;
pub const ox_stats_cp_types_OX_STATS_CP_MAP_TINY_SZ: ox_stats_cp_types = 6;
pub const ox_stats_cp_types_OX_STATS_CP_BLK_SMALL_SZ: ox_stats_cp_types = 7;
pub const ox_stats_cp_types_OX_STATS_CP_BLK_TINY_SZ: ox_stats_cp_types = 8;
pub const ox_stats_cp_types_OX_STATS_CP_SZ: ox_stats_cp_types = 9;
pub type ox_stats_cp_types = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvm_ppa_addr {
    pub __bindgen_anon_1: nvm_ppa_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvm_ppa_addr__bindgen_ty_1 {
    pub g: nvm_ppa_addr__bindgen_ty_1__bindgen_ty_1,
    pub ppa: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct nvm_ppa_addr__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl nvm_ppa_addr__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn sec(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_sec(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sec_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 0usize, 3u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_sec_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                3u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pl(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_pl(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pl_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 3usize, 2u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pl_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ch(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_ch(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ch_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 5usize, 12u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ch_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn lun(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u64) }
    }
    #[inline]
    pub fn set_lun(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn lun_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 17usize, 6u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_lun_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn pg(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_pg(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn pg_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 23usize, 12u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_pg_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                12u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn blk(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_blk(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn blk_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 35usize, 15u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_blk_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                35usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn rsv(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 14u8) as u64) }
    }
    #[inline]
    pub fn set_rsv(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn rsv_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 50usize, 14u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_rsv_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                50usize,
                14u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sec: u64,
        pl: u64,
        ch: u64,
        lun: u64,
        pg: u64,
        blk: u64,
        rsv: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                3u8,
                {
                    let sec: u64 = unsafe { ::core::mem::transmute(sec) };
                    sec as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                3usize,
                2u8,
                {
                    let pl: u64 = unsafe { ::core::mem::transmute(pl) };
                    pl as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                5usize,
                12u8,
                {
                    let ch: u64 = unsafe { ::core::mem::transmute(ch) };
                    ch as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                17usize,
                6u8,
                {
                    let lun: u64 = unsafe { ::core::mem::transmute(lun) };
                    lun as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                23usize,
                12u8,
                {
                    let pg: u64 = unsafe { ::core::mem::transmute(pg) };
                    pg as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                35usize,
                15u8,
                {
                    let blk: u64 = unsafe { ::core::mem::transmute(blk) };
                    blk as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                50usize,
                14u8,
                {
                    let rsv: u64 = unsafe { ::core::mem::transmute(rsv) };
                    rsv as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_memory_region {
    pub addr: u64,
    pub paddr: u64,
    pub size: u64,
    pub is_valid: u8,
}
pub type nvm_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(arg: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_callback {
    pub cb_fn: nvm_callback_fn,
    pub opaque: *mut ::core::ffi::c_void,
    pub ts: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_io_status {
    pub status: u8,
    pub nvme_status: u16,
    pub pg_errors: u32,
    pub total_pgs: u32,
    pub pgs_p: u16,
    pub pgs_s: u16,
    pub ret_t: u16,
    pub pg_map: [u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvm_mmgr_io_cmd {
    pub nvm_io: *mut nvm_io_cmd,
    pub ppa: nvm_ppa_addr,
    pub ch: *mut nvm_channel,
    pub callback: nvm_callback,
    pub prp: [u64; 32usize],
    pub md_prp: u64,
    pub status: u8,
    pub cmdtype: u8,
    pub pg_index: u32,
    pub pg_sz: u32,
    pub n_sectors: u16,
    pub sec_sz: u32,
    pub md_sz: u32,
    pub sec_offset: u16,
    pub force_sync_md: u8,
    pub force_sync_data: [u8; 32usize],
    pub sync_count: u32,
    pub rsvd: [u8; 128usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvm_io_cmd {
    pub cid: u64,
    pub channel: [*mut nvm_channel; 64usize],
    pub ppalist: [nvm_ppa_addr; 256usize],
    pub status: nvm_io_status,
    pub mmgr_io: [nvm_mmgr_io_cmd; 64usize],
    pub callback: nvm_callback,
    pub req: *mut ::core::ffi::c_void,
    pub mq_req: *mut ::core::ffi::c_void,
    pub opaque: *mut ::core::ffi::c_void,
    pub prp: [u64; 256usize],
    pub md_prp: [u64; 256usize],
    pub sec_sz: u32,
    pub md_sz: u32,
    pub n_sec: u32,
    pub slba: u64,
    pub cmdtype: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_mmgr_geometry {
    pub n_of_ch: u8,
    pub lun_per_ch: u8,
    pub blk_per_lun: u16,
    pub pg_per_blk: u16,
    pub sec_per_pg: u16,
    pub n_of_planes: u8,
    pub pg_size: u32,
    pub sec_oob_sz: u32,
    pub sec_per_pl_pg: u32,
    pub sec_per_blk: u32,
    pub sec_per_lun: u32,
    pub sec_per_ch: u32,
    pub pg_per_lun: u32,
    pub pg_per_ch: u32,
    pub blk_per_ch: u32,
    pub tot_sec: u32,
    pub tot_pg: u32,
    pub tot_blk: u32,
    pub tot_lun: u32,
    pub sec_size: u32,
    pub pl_pg_size: u32,
    pub blk_size: u32,
    pub lun_size: u32,
    pub ch_size: u32,
    pub tot_size: u32,
    pub pg_oob_sz: u32,
    pub pl_pg_oob_sz: u32,
    pub blk_oob_sz: u32,
    pub lun_oob_sz: u32,
    pub ch_oob_sz: u32,
    pub tot_oob_sz: u32,
}
pub const mmgr_flags_MMGR_FLAG_PL_CMD: mmgr_flags = 1;
pub const mmgr_flags_MMGR_FLAG_MIN_CP_TIME: mmgr_flags = 4;
pub type mmgr_flags = ::core::ffi::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_magic {
    pub rsvd: u32,
    pub magic: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_io_data {
    pub ch: *mut nvm_channel,
    pub n_pl: u8,
    pub pg_sz: u32,
    pub buf: *mut u8,
    pub pl_vec: *mut *mut u8,
    pub oob_vec: *mut *mut u8,
    pub sec_vec: *mut *mut *mut u8,
    pub meta_sz: u32,
    pub buf_sz: u32,
    pub mod_oob: *mut u8,
}
pub type nvm_mmgr_read_pg = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_mmgr_io_cmd) -> ::core::ffi::c_int,
>;
pub type nvm_mmgr_write_pg = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_mmgr_io_cmd) -> ::core::ffi::c_int,
>;
pub type nvm_mmgr_erase_blk = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_mmgr_io_cmd) -> ::core::ffi::c_int,
>;
pub type nvm_mmgr_get_ch_info = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_channel, arg2: u16) -> ::core::ffi::c_int,
>;
pub type nvm_mmgr_set_ch_info = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_channel, arg2: u16) -> ::core::ffi::c_int,
>;
pub type nvm_mmgr_exit = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut nvm_mmgr),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_mmgr_ops {
    pub read_pg: nvm_mmgr_read_pg,
    pub write_pg: nvm_mmgr_write_pg,
    pub erase_blk: nvm_mmgr_erase_blk,
    pub exit: nvm_mmgr_exit,
    pub get_ch_info: nvm_mmgr_get_ch_info,
    pub set_ch_info: nvm_mmgr_set_ch_info,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_mmgr {
    pub name: *const ::core::ffi::c_char,
    pub ops: *mut nvm_mmgr_ops,
    pub geometry: *mut nvm_mmgr_geometry,
    pub ch_info: *mut nvm_channel,
    pub flags: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvm_channel {
    pub ch_id: u16,
    pub ch_mmgr_id: u16,
    pub ns_pgs: u64,
    pub slba: u64,
    pub elba: u64,
    pub tot_bytes: u64,
    pub mmgr_rsv: u16,
    pub ftl_rsv: u16,
    pub mmgr: *mut nvm_mmgr,
    pub ftl: *mut nvm_ftl,
    pub geometry: *mut nvm_mmgr_geometry,
    pub mmgr_rsv_list: [nvm_ppa_addr; 16usize],
    pub ftl_rsv_list: [nvm_ppa_addr; 16usize],
    pub __bindgen_anon_1: nvm_channel__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvm_channel__bindgen_ty_1 {
    pub i: nvm_channel__bindgen_ty_1__bindgen_ty_1,
    pub nvm_info: u64,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct nvm_channel__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
impl nvm_channel__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ns_id(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_ns_id(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ns_id_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 0usize, 16u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ns_id_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ns_part(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 32u8) as u64) }
    }
    #[inline]
    pub fn set_ns_part(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ns_part_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 16usize, 32u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ns_part_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ftl_id(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_ftl_id(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ftl_id_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 48usize, 8u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_ftl_id_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                48usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_use(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_in_use(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_use_raw(this: *const Self) -> u64 {
        unsafe {
            ::core::mem::transmute(
                <__BindgenBitfieldUnit<
                    [u8; 8usize],
                >>::raw_get(::core::ptr::addr_of!((*this)._bitfield_1), 56usize, 8u8)
                    as u64,
            )
        }
    }
    #[inline]
    pub unsafe fn set_in_use_raw(this: *mut Self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            <__BindgenBitfieldUnit<
                [u8; 8usize],
            >>::raw_set(
                ::core::ptr::addr_of_mut!((*this)._bitfield_1),
                56usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ns_id: u64,
        ns_part: u64,
        ftl_id: u64,
        in_use: u64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit
            .set(
                0usize,
                16u8,
                {
                    let ns_id: u64 = unsafe { ::core::mem::transmute(ns_id) };
                    ns_id as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                16usize,
                32u8,
                {
                    let ns_part: u64 = unsafe { ::core::mem::transmute(ns_part) };
                    ns_part as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                48usize,
                8u8,
                {
                    let ftl_id: u64 = unsafe { ::core::mem::transmute(ftl_id) };
                    ftl_id as u64
                },
            );
        __bindgen_bitfield_unit
            .set(
                56usize,
                8u8,
                {
                    let in_use: u64 = unsafe { ::core::mem::transmute(in_use) };
                    in_use as u64
                },
            );
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_parser_cmd {
    pub name: [::core::ffi::c_char; 31usize],
    pub opcode: u8,
    pub queue_type: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_dma {
    pub ptr: *mut ::core::ffi::c_void,
    pub prp: u32,
    pub size: u64,
    pub direction: u8,
}
pub type ssd_os_extension_fn = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void) -> ::core::ffi::c_int,
>;
pub type ssd_os_stage_fn = ::core::option::Option<
    unsafe extern "C" fn(context: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
>;
pub type ssd_os_ctrl_fn = ::core::option::Option<
    unsafe extern "C" fn() -> ::core::ffi::c_int,
>;
pub type ssd_os_conn_ring_fn = ::core::option::Option<
    unsafe extern "C" fn(entry: *mut lring_entry) -> ::core::ffi::c_int,
>;
pub type ssd_os_conn_fn = ::core::option::Option<
    unsafe extern "C" fn(entry: *mut lring_entry) -> *mut pipeline,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct extension {
    pub magic: [::core::ffi::c_char; 4usize],
    pub name: [::core::ffi::c_char; 32usize],
    pub extension_fn: ssd_os_extension_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stage {
    pub magic: [::core::ffi::c_char; 4usize],
    pub name: [::core::ffi::c_char; 32usize],
    pub init_fn: ssd_os_ctrl_fn,
    pub exit_fn: ssd_os_ctrl_fn,
    pub stage_fn: ssd_os_stage_fn,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pipeline {
    pub name: [::core::ffi::c_char; 32usize],
    pub internal: [*mut ::core::ffi::c_void; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct connector {
    pub magic: [::core::ffi::c_char; 4usize],
    pub name: [::core::ffi::c_char; 32usize],
    pub nosched: u32,
    pub init_fn: ssd_os_ctrl_fn,
    pub exit_fn: ssd_os_ctrl_fn,
    pub conn_fn: ssd_os_conn_fn,
    pub ring_fn: ssd_os_conn_ring_fn,
}
pub type ssd_os_thread = ::core::option::Option<
    unsafe extern "C" fn(cpu: ::core::ffi::c_int, context: *mut ::core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltStatus {
    pub ready: u8,
    pub active: u8,
    pub allocated_memory: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltPage {
    pub state: u8,
    pub data: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltBlock {
    pub id: u16,
    pub life: u16,
    pub next_pg: *mut VoltPage,
    pub pages: *mut VoltPage,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltLun {
    pub blk_offset: *mut VoltBlock,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltCh {
    pub lun_offset: *mut VoltLun,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VoltCtrl {
    pub status: VoltStatus,
    pub blocks: *mut VoltBlock,
    pub luns: *mut VoltLun,
    pub channels: *mut VoltCh,
    pub edma: *mut u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct volt_dma {
    pub virt_addr: *mut u8,
    pub prp_index: u32,
    pub status: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct volt_info {
    pub channel_array: *mut nvm_channel,
    pub n_channels: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvm_ftl {
    pub _address: u8,
}
unsafe extern "C" {
    pub fn lring_flag_on(ring: *mut lring, flag: ::core::ffi::c_int);
    pub fn lring_flag_off(ring: *mut lring, flag: ::core::ffi::c_int);
    pub fn lring_flag_check(
        ring: *mut lring,
        flag: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn lring_create(
        name: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        mem: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut lring;
    pub fn lring_print(ring: *mut lring);
    pub fn ox_dma(dma: *mut nvm_dma) -> ::core::ffi::c_int;
    pub fn program_load(elf: *mut u8, size: u32) -> ::core::ffi::c_int;
    pub fn program_pipe(file: *mut u8) -> ::core::ffi::c_int;
    pub fn program_connect(file: *mut u8) -> ::core::ffi::c_int;
    pub fn loader_extensions_print();
    pub fn loader_stages_print();
    pub fn loader_connectors_print();
    pub fn timer_interrupt_on(
        interval: ::core::ffi::c_int,
        function: *mut ::core::ffi::c_void,
    );
    pub fn timer_interrupt_off();
    pub fn thread_yield(
        cpu: ::core::ffi::c_int,
        thread: ssd_os_thread,
        context: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    pub fn ssd_os_print_s(s: *const ::core::ffi::c_char);
    pub fn ssd_os_print_c(c: ::core::ffi::c_char);
    pub fn ssd_os_print_i(x: ::core::ffi::c_ulong);
    pub fn ssd_os_print_h(x: ::core::ffi::c_ulong);
    pub fn ssd_os_print_ss(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_ss_l(
        s1: *const ::core::ffi::c_char,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_sis(
        s1: *const ::core::ffi::c_char,
        i: ::core::ffi::c_ulong,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_sis_l(
        s1: *const ::core::ffi::c_char,
        i: ::core::ffi::c_ulong,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_shs(
        s1: *const ::core::ffi::c_char,
        h: ::core::ffi::c_ulong,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_shs_l(
        s1: *const ::core::ffi::c_char,
        h: ::core::ffi::c_ulong,
        s2: *const ::core::ffi::c_char,
    );
    pub fn ssd_os_print_lock();
    pub fn ssd_os_print_unlock();
    pub fn ssd_os_ncores() -> ::core::ffi::c_int;
    pub fn ssd_os_this_cpu(name: *mut ::core::ffi::c_char) -> ::core::ffi::c_int;
    pub fn ssd_os_mem_get(key: ::core::ffi::c_int) -> *mut ::core::ffi::c_void;
    pub fn ssd_os_mem_size(key: ::core::ffi::c_int) -> ::core::ffi::c_int;
    pub fn ssd_os_mem_nregions() -> ::core::ffi::c_int;
    pub fn ssd_os_mem_cpy(
        dest: *mut ::core::ffi::c_void,
        src: *const ::core::ffi::c_void,
        n: u32,
    ) -> *mut ::core::ffi::c_void;
    pub fn ssd_os_sleep(sec: ::core::ffi::c_int);
    pub fn ssd_os_msleep(msec: ::core::ffi::c_int);
    pub fn ssd_os_usleep(usec: ::core::ffi::c_int);
    pub fn ssd_os_timer_interrupt_on(
        interval: ::core::ffi::c_int,
        function: *mut ::core::ffi::c_void,
    );
    pub fn ssd_os_timer_interrupt_off();
    pub fn ssd_os_lring_create(
        name: *mut ::core::ffi::c_char,
        size: ::core::ffi::c_int,
        mem: *mut ::core::ffi::c_void,
        flags: ::core::ffi::c_int,
    ) -> *mut lring;
    pub fn ssd_os_lring_enqueue(
        ring: *mut lring,
        entry: *mut lring_entry,
    ) -> ::core::ffi::c_int;
    pub fn ssd_os_lring_enqueue_m(
        ring: *mut lring,
        entry: *mut lring_entry,
    ) -> ::core::ffi::c_int;
    pub fn ssd_os_lring_dequeue(
        ring: *mut lring,
        entry: *mut lring_entry,
    ) -> ::core::ffi::c_int;
    pub fn ssd_os_lring_dequeue_m(
        ring: *mut lring,
        entry: *mut lring_entry,
    ) -> ::core::ffi::c_int;
    pub fn ssd_os_lring_print(ring: *mut lring);
    pub fn ssd_os_get_connection(
        connector_name: *mut ::core::ffi::c_char,
        pipe_name: *mut ::core::ffi::c_char,
    ) -> *mut pipeline;
    pub fn volt_get_ch_info(ch_info: *mut volt_info) -> ::core::ffi::c_int;
    pub fn volt_get_geometry(g: *mut nvm_mmgr_geometry) -> ::core::ffi::c_int;
    pub fn volt_get_last_address(ptr: *mut ::core::ffi::c_void) -> ::core::ffi::c_int;
}
